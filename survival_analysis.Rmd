---
title: "Survival Analysis"
author: "Nikhil, Atharva & Urjit"
date: "2024-04-05"
output: pdf_document
---

```{r}
library(readr)
library(dplyr)
library(ggplot2)
library(reshape2)
```


### Import Data & Preprocessing

```{r}
# Define column names
column1 <- c("machine_name", "cycle", "operational_setting_1", "operational_setting_2", "operational_setting_3")
column2 <- paste0("sensor_measurement_", sprintf("%02d", 1:21))
columns <- c(column1, column2)
```

```{r}
# Read Data
turbofan_df <- read_delim("data/train_FD002.txt",
                          delim = " ", col_names = columns, show_col_types = FALSE, trim_ws = TRUE)

# Dropping Empty Columns
turbofan_df <- turbofan_df %>%
  select(-X27, -X28)

head(turbofan_df)
```

#### Create Censored Data 

If we examine the data above, we see that we do not have right-censored observations. To obtain such observations, we follow these steps:

1. Select the maximum cycle until each machine breaks down.
2. Assume an endpoint for the observation period.

By doing this, we ensure that our data includes right-censored observations. This is crucial for survival analysis, as it allows us to properly analyze situations where the event of interest (in this case, machine breakdown) has not occurred by the end of the observation period for some subjects (machines). This approach provides a more comprehensive understanding of the lifespan and reliability of the machines by including both those that have failed and those that are still operational by the end of the study.

```{r}
turbofan_df <- turbofan_df %>% 
  group_by(machine_name) %>%
  mutate(max_cycle = max(cycle)) %>%
  filter(cycle == max_cycle) %>%
  ungroup() 

head(turbofan_df)
```

```{r}
# Create the lollipop plot
ggplot(turbofan_df, aes(x = machine_name, y = cycle)) +
  geom_segment(aes(x = machine_name, xend = machine_name, y = 1, yend = cycle), color = 'skyblue') +
  geom_point(color = 'blue', size = 1.5) +
  geom_point(aes(y = 1), color = 'red', size = 1.5) +
  coord_flip() + 
  labs(title = "Max. Cycle", x = "Machine ID", y = "Cycle") +
  theme_minimal()

```

We assume that the final observation time limit is 220 cycles so that when the machine is still active after 220 cycles, the machine will be considered right censored

```{r}
# Create status column
turbofan_df <- turbofan_df %>%
  mutate(status = ifelse(cycle > 200, FALSE, TRUE))

head(turbofan_df)
```

Machine status True indicates that the machine is damaged within the observation time period, while False indicates that the machine has not experienced any damage during the observation time period

```{r}
table(turbofan_df$status)
```

### Exploratory Data Analysis

The next step is to carry out feature selection, namely selecting columns/variables that can be included in the model

#### Correlation Heatmap

We can check the correlation between columns of candidate predictors to see if there is a high correlation between predictors. Variables that have a high correlation with other variables need to be selected only to avoid multicollinearity

```{r}
# Calculate the squared correlation matrix and convert to long format
squared_corr <- cor(turbofan_df)^2
melted_corr <- melt(squared_corr)

# Filter for stronger correlations to reduce clutter
threshold <- 0.5 # Example threshold, adjust as needed
melted_corr_filtered <- subset(melted_corr, value >= threshold & Var1 != Var2)

# Create the heatmap
ggplot(melted_corr_filtered, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank()) +
  labs(fill = "Squared\nCorrelation") +
  geom_text(aes(label = sprintf("%.2f", value)), size = 3)
```

In the plot above, the correlation between variables looks quite high. In this case we will try to first select the columns sensor_measurement_04, sensor_measurement_08, sensor_measurement_11, sensor_measurement_14 

```{r}
# Selected numeric and category columns
selected_columns <- c("sensor_measurement_04", "sensor_measurement_11", "sensor_measurement_14", "operational_setting_3", "sensor_measurement_16", "status", "cycle")

# Assuming 'turbofan_df' is a dataframe and columns are appropriately formatted
cleaned_data <- turbofan_df[selected_columns]

# Calculate the squared correlation matrix and convert to long format
squared_corr <- cor(cleaned_data)^2
melted_corr <- melt(squared_corr)

# Filter for stronger correlations to reduce clutter
threshold <- 0.5 # Example threshold, adjust as needed
melted_corr_filtered <- subset(melted_corr, value >= threshold & Var1 != Var2)

# Create the heatmap
ggplot(melted_corr_filtered, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank()) +
  labs(fill = "Squared\nCorrelation") +
  geom_text(aes(label = sprintf("%.2f", value)), size = 3)

```

#### Check for Uniqueness

First we will check for many unique values in each column and then the columns that have few unique values will be replaced with the category data type.

```{r}
unique_counts <- sapply(turbofan_df, function(x) length(unique(x)))

cat("Unique values count per column:\n")
for(col in names(unique_counts)) {
  cat(col, ":", unique_counts[col], "\n")
}
```

```{r}
# Change specified columns to category (factor)
turbofan_df <- turbofan_df %>%
  mutate(across(c(operational_setting_3, sensor_measurement_16, sensor_measurement_19), as.factor))

# View information about the dataframe to confirm the changes
glimpse(turbofan_df)
```

### Data Preparation for Modelling

The next step is to prepare the data for modeling. Things to pay attention to are:
1. For columns with category types, One Hot Encoding needs to be done.
2. For target data, it needs to be written in array form with each element being a tuple consisting of the machine state (True/False) and the time/cycle.

```{r}

```












