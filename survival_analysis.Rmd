---
title: "Survival Analysis"
author: "Nikhil, Atharva & Urjit"
date: "2024-04-05"
output: pdf_document
---

```{r}
library(readr)
library(dplyr)
library(ggplot2)
library(reshape2)
library(survival)
library(glmnet)
```


### Import Data & Preprocessing

```{r}
# Define column names
column1 <- c("machine_name", "cycle", "operational_setting_1", "operational_setting_2", "operational_setting_3")
column2 <- paste0("sensor_measurement_", sprintf("%02d", 1:21))
columns <- c(column1, column2)
```

```{r}
# Read Data
turbofan_df <- read_delim("data/train_FD002.txt",
                          delim = " ", col_names = columns, show_col_types = FALSE, trim_ws = TRUE)

# Dropping Empty Columns
turbofan_df <- turbofan_df %>%
  select(-X27, -X28)

head(turbofan_df)
```

#### Create Censored Data 

If we examine the data above, we see that we do not have right-censored observations. To obtain such observations, we follow these steps:

1. Select the maximum cycle until each machine breaks down.
2. Assume an endpoint for the observation period.

By doing this, we ensure that our data includes right-censored observations. This is crucial for survival analysis, as it allows us to properly analyze situations where the event of interest (in this case, machine breakdown) has not occurred by the end of the observation period for some subjects (machines). This approach provides a more comprehensive understanding of the lifespan and reliability of the machines by including both those that have failed and those that are still operational by the end of the study.

```{r}
turbofan_df <- turbofan_df %>% 
  group_by(machine_name) %>%
  mutate(max_cycle = max(cycle)) %>%
  filter(cycle == max_cycle) %>%
  ungroup() 

head(turbofan_df)
```

```{r}
# Create the lollipop plot
ggplot(turbofan_df, aes(x = machine_name, y = cycle)) +
  geom_segment(aes(x = machine_name, xend = machine_name, y = 1, yend = cycle), color = 'skyblue') +
  geom_point(color = 'blue', size = 1.5) +
  geom_point(aes(y = 1), color = 'red', size = 1.5) +
  coord_flip() + 
  labs(title = "Max. Cycle", x = "Machine ID", y = "Cycle") +
  theme_minimal()

```

We assume that the final observation time limit is 220 cycles so that when the machine is still active after 220 cycles, the machine will be considered right censored

```{r}
# Create status column
turbofan_df <- turbofan_df %>%
  mutate(status = ifelse(cycle > 200, FALSE, TRUE))

head(turbofan_df)
```

Machine status True indicates that the machine is damaged within the observation time period, while False indicates that the machine has not experienced any damage during the observation time period

```{r}
table(turbofan_df$status)
```

### Exploratory Data Analysis

The next step is to carry out feature selection, namely selecting columns/variables that can be included in the model

#### Correlation Heatmap

We can check the correlation between columns of candidate predictors to see if there is a high correlation between predictors. Variables that have a high correlation with other variables need to be selected only to avoid multicollinearity

```{r}
# Calculate the squared correlation matrix and convert to long format
squared_corr <- cor(turbofan_df)^2
melted_corr <- melt(squared_corr)

# Filter for stronger correlations to reduce clutter
threshold <- 0.5 # Example threshold, adjust as needed
melted_corr_filtered <- subset(melted_corr, value >= threshold & Var1 != Var2)

# Create the heatmap
ggplot(melted_corr_filtered, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank()) +
  labs(fill = "Squared\nCorrelation") +
  geom_text(aes(label = sprintf("%.2f", value)), size = 3)
```

In the plot above, the correlation between variables looks quite high. In this case we will try to first select the columns sensor_measurement_04, sensor_measurement_08, sensor_measurement_11, sensor_measurement_14 

```{r}
# Selected numeric and category columns
selected_columns <- c("sensor_measurement_04", "sensor_measurement_11", "sensor_measurement_14", "operational_setting_3", "sensor_measurement_16", "status", "cycle")

# Assuming 'turbofan_df' is a dataframe and columns are appropriately formatted
cleaned_data <- turbofan_df[selected_columns]

# Calculate the squared correlation matrix and convert to long format
squared_corr <- cor(cleaned_data)^2
melted_corr <- melt(squared_corr)

# Filter for stronger correlations to reduce clutter
threshold <- 0.5 # Example threshold, adjust as needed
melted_corr_filtered <- subset(melted_corr, value >= threshold & Var1 != Var2)

# Create the heatmap
ggplot(melted_corr_filtered, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank()) +
  labs(fill = "Squared\nCorrelation") +
  geom_text(aes(label = sprintf("%.2f", value)), size = 3)

```

#### Check for Uniqueness

First we will check for many unique values in each column and then the columns that have few unique values will be replaced with the category data type.

```{r}
unique_counts <- sapply(turbofan_df, function(x) length(unique(x)))

cat("Unique values count per column:\n")
for(col in names(unique_counts)) {
  cat(col, ":", unique_counts[col], "\n")
}
```

```{r}
# Change specified columns to category (factor)
turbofan_df <- turbofan_df %>%
  mutate(across(c(operational_setting_3, sensor_measurement_16, sensor_measurement_19), as.factor))

# View information about the dataframe to confirm the changes
glimpse(turbofan_df)
```

### Survival Analysis

```{r}
fit.surv <- survfit(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ 1)
plot(fit.surv, xlab = "Cycles", ylab = "Estimated Probability for Survival", 
     main='Kaplan-Meier Survival Curve')

summary(fit.surv, times =150)

print(fit.surv)
```
The Kaplan-Meier estimator revealed declining survival probabilities for turbofan engines with increasing operational cycles, pinpointing critical periods of heightened failure risk.

#### Impact of Settings

##### Operational Setting 3
```{r}
# Kaplan-Mier Plot
fit.op <- survfit(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$operational_setting_3)
plot(fit.op, xlab = "Cycles", ylab = "Estimated Probability for Survival", 
     col = c (2 ,4), main='Kaplan-Meier Survival Curve Stratified with 
     operational_setting_3')
legend_labels <- levels(turbofan_df$operational_setting_1)

legend("topright", levels(turbofan_df$operational_setting_3), col = c(2,4), lty = 1)   
```

```{r}
#Log-Rank Test
logrank.test <- survdiff(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$operational_setting_3)

logrank.test
```
```{r}
coxph(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$operational_setting_3)
```
The test suggests the there is significant difference between the survival curves

```{r}
# Kaplan-Mier Survival Curve
fit.sm <- survfit(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$sensor_measurement_16)
plot(fit.sm, xlab = "Cycles", ylab = "Estimated Probability for Survival", 
     col = c(2,4), main='Kaplan-Meier Survival Curve Stratified with 
     sensor_measurement_16')

legend("topright", levels(turbofan_df$sensor_measurement_16), col = c(2,4), lty = 1)   
```

```{r}
# LogRank Test
logrank.test <- survdiff(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$sensor_measurement_16)

logrank.test
```

```{r}
# Cox Proportional Hazards Model
coxph(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$sensor_measurement_16)
```
##### Sensor Measurement 16

```{r}
# Kaplan-Mier Plot
fit.sm <- survfit(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$sensor_measurement_19)
plot(fit.sm, xlab = "Cycles", ylab = "Estimated Probability for Survival", 
     col = c(2,4), main='Kaplan-Meier Survival Curve 
     Stratified with sensor_measurement_19')

legend("topright", levels(turbofan_df$sensor_measurement_19), col = c(2,4), lty = 1)   
```
```{r}
#Log-Rank test
logrank.test <- survdiff(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$sensor_measurement_19)

logrank.test
```

```{r}
#Cox-Proportional test
coxph(Surv(turbofan_df$max_cycle, turbofan_df$status) ~ turbofan_df$sensor_measurement_19)
```
#levels(sensor_measurement_16)
#TODO fix this part ----------------
model <- coxph(Surv(max_cycle, status) ~ ., data = turbofan_df)
summary(model)
------------------------------------

### GLMNet Model Building

```{r}
p <- ncol(turbofan_df) - 2

data <- as.matrix(turbofan_df[, 3:p])
show_fit=glmnet(data,Surv(turbofan_df$max_cycle, turbofan_df$status),standardize=TRUE,
                lambda=seq(0,0.25,.001),alpha=1,family = "cox")
print(show_fit)

plot(show_fit,label=TRUE)
plot(show_fit,xvar = "lambda",label=TRUE) 
```

```{r}
# Partial Deviance
surv_model <- cv.glmnet(data,Surv(turbofan_df$max_cycle, turbofan_df$status), family = "cox", 
                        type.measure = "deviance",alpha=1,nfolds = 10)
plot(surv_model)
print(surv_model)
```
```{r}
lambda_opt <- surv_model$lambda.1se

# Fit the model using the optimal lambda value
fit <- glmnet(data,Surv(turbofan_df$max_cycle, turbofan_df$status), family = "cox", 
              type.measure = "deviance",alpha=1,lambda = lambda_opt)
coef(fit)
```
```{r}
predictions <- predict(fit, newx = data, type = "response")


c_index <- Cindex(predictions,Surv(turbofan_df$max_cycle, turbofan_df$status))
c_index
```

###### Cindex
```{r}
surv_model_C = cv.glmnet(data,Surv(turbofan_df$max_cycle, turbofan_df$status), 
                         family = "cox", type.measure = "C", 
                         alpha=1,nfolds = 10)

lambda_opt <- surv_model_C$lambda.1se

plot(surv_model_C)
print(surv_model_C)
```

##### Fit the model using the optimal lambda value
```{r}
fit_C <- glmnet(data,Surv(turbofan_df$max_cycle, turbofan_df$status), 
                family = "cox", 
                type.measure = "C",alpha=1,lambda = lambda_opt)
coef(fit_C)
```

##### Make predictions
```{r}
predictions <- predict(fit_C, newx = data, type = "response")
```
##### Evaluate the model performance using concordance index (c-index)
```{r}
c_index <- Cindex(predictions,Surv(turbofan_df$max_cycle, turbofan_df$status))
c_index
```